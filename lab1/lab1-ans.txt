----------------------------------------------------------------------
1.1
----------------------------------------------------------------------
关于指针初始化和赋值

void test1(){
    int *a, b= 0;
    a = &b;
    *a = *a + 2;
    printf("%d\n", *a);
}

#include <stdlib.h>
void test1(){
    int *a = malloc(sizeof(*a));
    *a = 3;
    *a = *a + 2;
    printf("%d\n", *a);
}

------------------------------------------------------------------------
1.2
------------------------------------------------------------------------
指针的定义

void test2() {
    int *a, *b;
    a = (int *) malloc(sizeof (int));
    b = (int *) malloc(sizeof (int));

    if (!(a && b)) {
        printf("Out of memory\n");
        exit(-1);
    }
    *a = 2;
    *b = 3;
}

-----------------------------------------------------------------------
1.3
-----------------------------------------------------------------------
注意分配空间大小

void test3() {
    int i, *a = (int *) malloc(seizof(int)*1000);

    if (!a) {
        printf("Out of memory\n");
        exit(-1);
    }
    for (i = 0; i < 1000; i++)
        *(i + a) = i;
}

----------------------------------------------------------------------------
1.4
----------------------------------------------------------------------------
分两次分配，现分行，后分列

void test4() {
    int **a = (int **) malloc(3 * sizeof (int *));
    for(i=0;i++;i<3)    *(a+i) = (int *) malloc(100 * seizof(int));
    a[1][1] = 5;
}

---------------------------------------------------------------------------
1.5
---------------------------------------------------------------------------
使用是注意是指针还是变量

void test5() {
    int *a = (int *) malloc(sizeof (int));
    scanf("%d", *a);
    if (!*a)
        printf("Value is 0\n");
}

===============================================================================
Question 2: Parallelization (30 points)
================================================================================
--------------------------------------------------------------------------------
2.1
--------------------------------------------------------------------------------
第一个容易实现，因为y[n]只于x相关，x作为input，可以直接访问。
而第二个，还依赖前两项y，并行性不够好。


--------------------------------------------------------------------------------
2.2
--------------------------------------------------------------------------------
可以继续向下拓展
y[n] = c * x[n] + (1 - c) * y[n - 1]
     = c * x[n] + (1 - c)*c * x[n-1] + (1 - c)^2 * y[n - 2]
     = c * x[n] + (1 - c)*c * x[n-1] + (1 - c)^2*c * x[n-2] + (1 - c)^3 * y[n - 3]
     = ...
 因为c接近于1，所以（1-c）接近0，高次幂后约等于0，所以后面可以省略。

y[n] = c * x[n] + (1 - c)*c * x[n-1] + (1 - c)^2*c * x[n-2]
即截断后面的，等同于带系数的SMA。

================================================================================
Question 3: Small-Kernel Convolution
================================================================================
